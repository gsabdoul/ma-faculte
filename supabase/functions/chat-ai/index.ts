// @ts-ignore
declare const Deno: any;

const GEMINI_API_KEY = Deno.env.get('GEMINI_API_KEY')

const corsHeaders = {
    'Access-Control-Allow-Origin': '*',
    'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
}

Deno.serve(async (req: Request) => {
    // Handle CORS preflight requests
    if (req.method === 'OPTIONS') {
        return new Response('ok', { headers: corsHeaders })
    }

    try {
        // 1. Check API Key
        if (!GEMINI_API_KEY) {
            throw new Error('Configuration Error: GEMINI_API_KEY is missing in secrets.')
        }

        // 2. Parse Body
        let body;
        try {
            body = await req.json()
        } catch (e) {
            throw new Error('Invalid JSON body')
        }

        const { messages, userContext, subjectContext } = body
        if (!messages || !Array.isArray(messages)) {
            throw new Error('Invalid payload: messages array is required')
        }

        // 3. Format for Gemini
        let systemInstruction = "Tu es un assistant pédagogique intelligent pour une application universitaire."

        if (userContext) {
            systemInstruction += `\n\nContexte de l'étudiant :
            - Prénom : ${userContext.prenom || 'Inconnu'}
            - Nom : ${userContext.nom || ''}
            - Université : ${userContext.universite || 'Non spécifiée'}
            - Faculté : ${userContext.faculte || 'Non spécifiée'}
            - Niveau : ${userContext.niveau || 'Non spécifié'}
            
            Modules (Cours) suivis : ${userContext.modules && userContext.modules.length > 0 ? userContext.modules.join(', ') : 'Aucun module spécifique identifié.'}
            
            Adapte tes réponses en fonction de ce niveau d'étude et de ces modules. Tu peux suggérer des ressources en lien avec ces cours.`
        }

        // Préparer le contenu pour Gemini
        const lastMessage = messages[messages.length - 1];
        const history = messages.slice(0, -1).map((msg: any) => ({
            role: msg.sender === 'user' ? 'user' : 'model',
            parts: [{ text: msg.text }]
        }));

        const currentMessageParts: any[] = [{ text: lastMessage.text }];

        // Si un PDF est fourni, le télécharger et l'ajouter
        if (subjectContext && subjectContext.url) {
            try {
                console.log('Downloading PDF from:', subjectContext.url);
                const pdfRes = await fetch(subjectContext.url);
                if (pdfRes.ok) {
                    const pdfBlob = await pdfRes.blob();
                    const arrayBuffer = await pdfBlob.arrayBuffer();
                    const base64Pdf = btoa(
                        new Uint8Array(arrayBuffer)
                            .reduce((data, byte) => data + String.fromCharCode(byte), '')
                    );

                    currentMessageParts.unshift({
                        inlineData: {
                            mimeType: "application/pdf",
                            data: base64Pdf
                        }
                    });

                    systemInstruction += `\n\nUn document PDF (Sujet d'examen ou cours: "${subjectContext.title}") est joint à ce message. Analyse-le pour répondre aux questions de l'étudiant.`;
                } else {
                    console.error('Failed to download PDF:', pdfRes.status);
                }
            } catch (e) {
                console.error('Error processing PDF:', e);
            }
        }

        const contents = [
            ...history,
            {
                role: 'user',
                parts: currentMessageParts
            }
        ];

        // 4. Call Gemini API
        const response = await fetch(
            `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${GEMINI_API_KEY}`,
            {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    contents: contents,
                    systemInstruction: {
                        parts: [{ text: systemInstruction }]
                    }
                }),
            }
        )

        if (!response.ok) {
            const errorData = await response.json().catch(() => ({}))
            console.error('Gemini API Error:', errorData)
            throw new Error(`Gemini API Error (${response.status}): ${errorData.error?.message || response.statusText}`)
        }

        const data = await response.json()

        if (!data.candidates || data.candidates.length === 0) {
            console.error('No candidates in response:', data)
            throw new Error('No response generated by Gemini.')
        }

        const aiResponse = data.candidates[0].content.parts[0].text

        return new Response(
            JSON.stringify({ text: aiResponse }),
            { headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
        )

    } catch (error: any) {
        console.error('Edge Function Error:', error)
        return new Response(
            JSON.stringify({ error: error.message || 'Internal Server Error' }),
            {
                status: 200, // Return 200 to avoid client-side exception masking the error message
                headers: { ...corsHeaders, 'Content-Type': 'application/json' }
            }
        )
    }
})
